# -*- coding: utf-8 -*-
"""MovierecommendationSystem

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1IkryqW1Hc4Y59nBB1jEFoOXDowGcucVA
"""

import numpy as np
import pandas as pd

credits = pd.read_csv("credits.csv")
movies = pd.read_csv("movies.csv")

#displaying the credits data set
credits

#displaying the movies data set
movies

#Display all columns and rows
pd.set_option('display.max_columns', None)
pd.set_option('display.max_rows', None)

# Shows first few rows
credits.head()

#merging
movies_df = movies.merge(credits, on='title')

# Display the number of rows and columns in the movies_df
movies_df.shape

#showing few row of movies
movies_df.head()

#informations of movies df
movies_df.info()

#Keep only the relevant columns for the recommendation system
movies_df = movies_df[['movie_id', 'title', 'overview', 'genres', 'keywords', 'cast', 'crew']]

movies_df.head()

movies_df.info()

movies_df.isnull().sum()

movies_df.dropna(inplace=True)

#Check for duplicate rows in the dataset
movies_df.duplicated().sum()

#View the genres of the first movie entry
movies_df.iloc[0].genres

import ast

#convert stringified list of dicts (or actual list) to a list of names
def convert(obj):
    if isinstance(obj, list):
        # Assume it's a list of dictionaries like [{'name': 'Action'}]
        return [item['name'] if isinstance(item, dict) and 'name' in item else item for item in obj]
    try:
        # Try parsing the string to a Python object
        data = ast.literal_eval(obj)
        return [item['name'] if isinstance(item, dict) and 'name' in item else item for item in data]
    except:
        return []

# Apply the 'convert' function to multiple columns
movies_df['genres'] = movies_df['genres'].apply(convert)
movies_df['keywords'] = movies_df['keywords'].apply(convert)
movies_df['cast'] = movies_df['cast'].apply(convert)

# Display the first 5 rows
movies_df.head()

#Extract top 3 names from a stringified list of dictionaries
from re import L
def convert3(obj):
    L = []  # Initialize empty list
    counter =    # Initialize empty list
    for i in ast.literal_eval(obj):   # Safely convert string to list of dicts
        if counter != 3:
            L.append(i['name'])  # Initialize empty list
            counter += 1
        else:
            break    # Stop after 3 items
    return L

#Extract top 3 cast members' names from the 'cast' column
movies_df['cast'] = movies_df['cast'].apply(convert3)

movies_df.head()

# Extract the director's name from the 'crew' column
def fetch_director(obj):
    L = []
    for i in ast.literal_eval(obj):   # Convert string to list of dicts
        if i['job'] == 'Director':  # Check if the job is Director
            L.append(i['name'])     # Add the director's name to the list
            break                   # Stop after the first director found
    return L

print(movies.columns.tolist())

movies.columns = movies.columns.str.strip()

# Apply the fetch_director function to the 'crew' column of movies_df
movies_df['crew'] = movies_df['crew'].apply(fetch_director)

movies

movies['overview'][0]

# Fill any potential missing values (NaN) with an empty string
movies['overview'].fillna('', inplace=True)
# Convert the 'overview' column to string type to ensure all elements are strings
movies['overview'] = movies['overview'].astype(str)
# Now apply the split function
movies['overview'] = movies['overview'].apply(lambda x:x.split())

# Display the updated movies DataFrame
movies

# Remove spaces from the elements within the list columns of movies_df
movies_df['genres'] = movies_df['genres'].apply(lambda x:[i.replace(" ", "") for i in x])
movies_df['keywords'] = movies_df['keywords'].apply(lambda x:[i.replace(" ", "") for i in x])
movies_df['cast'] = movies_df['cast'].apply(lambda x:[i.replace(" ", "") for i in x])
movies_df['crew'] = movies_df['crew'].apply(lambda x:[i.replace(" ", "") for i in x])

movies

# Fill any potential missing values (NaN) in the 'overview' column of movies_df with an empty string
movies_df['overview'].fillna('', inplace=True)
# Convert the 'overview' column of movies_df to string type
movies_df['overview'] = movies_df['overview'].astype(str)
# Apply the split function to the 'overview' column of movies_df
movies_df['overview'] = movies_df['overview'].apply(lambda x:x.split())

# Create the 'tags' column in the movies_df DataFrame by concatenating the processed list columns
# The overview column in movies_df is already a list of words due to the split() operation above.
movies_df['tags'] = movies_df['overview'] + movies_df['genres'] + movies_df['keywords'] + movies_df['cast'] + movies_df['crew']

movies

new_df=movies_df[['movie_id', 'title', 'tags']]
new_df

new_df['tags'] = new_df['tags'].apply(lambda x:" ".join(x))

new_df

new_df['tags'][0]

new_df['tags']=new_df['tags'].apply(lambda x:x.lower())

new_df.head()

# Initialize CountVectorizer to convert text to token counts
# Limit vocabulary to top 5000 words
# Remove common English stopwords
from sklearn.feature_extraction.text import CountVectorizer
cv = CountVectorizer(max_features=5000, stop_words='english')

# Fit the vectorizer and transform 'tags' text data into numerical vectors
# Then check the shape of the resulting matrix (num_movies x vocab_size)
cv.fit_transform(new_df['tags']).toarray().shape

#Convert movie tags into numerical feature vectors using CountVectorizer
vector = cv.fit_transform(new_df['tags']).toarray()

vector[0]

len(cv.get_feature_names_out())

import nltk

from nltk.stem.porter import PorterStemmer
ps = PorterStemmer()  # Initialize Porter Stemmer

#Stem each word in the input text and return the joined stemmed string
def stem(text):
  y=[]
  for i in text.split():  # Split text into words
        y.append(ps.stem(i))  # Stem each word and append
    return " ".join(y)  # Join stemmed words back into a string

new_df['tags']=new_df['tags'].apply(stem)

#Import cosine similarity function to measure similarity between movie vectors
from sklearn.metrics.pairwise import cosine_similarity

#Compute the cosine similarity matrix between all movie vector
cosine_similarity(vector)

cosine_similarity(vector).shape

#Calculate cosine similarity matrix for movie feature vectors
similarity = cosine_similarity(vector)

similarity[0]

similarity[0].shape

#Find top 5 movies similar to the first movie (excluding itself)
sorted(list(enumerate(similarity[0])), reverse=True, key=lambda x:x[1])[1:6]

# Recommend top 5 movies similar to the given movie title
def recommend(movie):
  # Find index of the movie in new_df
  movie_index = new_df[new_df['title'] == movie].index[0]
  # Get similarity scores for that movie
  distances = similarity[movie_index]
  # Sort movies based on similarity score (descending) and exclude the first one (the movie itself)
  movies_list = sorted(list(enumerate(distances)), reverse=True, key=lambda x:x[1])[1:6]

# Print the titles of the top 5 recommended movies
  for i in movies_list:
    print(new_df.iloc[i[0]].title)

# to print top 5 movies similar to 'Avatar'
recommend('Avatar')

# to print top 5 movies similar to 'Batman Begins'
recommend('Batman Begins')